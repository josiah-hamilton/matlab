%% TODO

% Lines 16-19: Prove downsampling-then-filtering wont introduce destructive aliasing. 
%    If so design a decimator filter that is independent from the interpolater filter
% PSD estimates of signals 
% Decibal Scale Plots

%% Project 3 part 2
% Josiah Hamilton
% William Vining
% 2017 December 8
% Dr. Tanja Karp
clear; close all

%% Decisions and Analysis 

% Either
%   We went with a single filter for decimator/interpolator because could not prove destructive aliasing would not happen
% OR
%   We went with separate decimator and interpolator filters because we could prove destructive aliasing would not happen

% With the two filters below we have a total of (2*68+108)= 244 multiplications in the chain, compared to the 2024 order equiripple filter in 1 (2025)

% x[n]                     y1[n]         y2[n]                       y[n]
% --> [ Hd(z) ] -> [ v 32 ] --> [ Hk(z) ] --> [ ^ 32 ] --> [ Hi(z) ] -->
% fpass: 30Hz, fstop: 40Hz, fs_lo = 250Hz These are particularly important for the kernel filter
% Outside of that, we'll be much more flexible to reduce order of the decimator and interpolator filters.
% Also Hd(z) = Hi(z), fpass: 30Hz, fstop: fs_lo - fpass = 220Hz


%% Referencing Milic pg 277 fig 9.2



%% Filters

% Decimator and Interpolator Filters. fs: 8kHz, fpass: 30Hz, fstop: 220Hz 

% Generated by MATLAB(R) 9.3 and Signal Processing Toolbox 7.5.
% Generated on: 08-Dec-2017 14:23:19
% Coefficient Format: Decimal
% Discrete-Time FIR Filter (real)        
% -------------------------------        
% Filter Structure  : Direct-Form FIR    
% Filter Length     : 108                
% Stable            : Yes                
% Linear Phase      : Yes (Type 2)  


% Kernel Filter. fs: 250Hz, fpass:30Hz, fstop: 40Hz

% Generated by MATLAB(R) 9.3 and Signal Processing Toolbox 7.5.
% Generated on: 08-Dec-2017 12:44:17
% Coefficient Format: Decimal
% Discrete-Time FIR Filter (real)         
% -------------------------------         
% Filter Structure  : Direct-Form FIR     
% Filter Length     : 68                  
% Stable            : Yes                 
% Linear Phase      : Yes (Type 2)

fileID_Hk = fopen('kernel.fcf','r');
fileID_Ha = fopen('ha.fcf','r');
formatSpec = '%f';
Hk = fscanf(fileID_Hk,formatSpec);
Ha = fscanf(fileID_Ha,formatSpec);
fclose(fileID_Hk);
fclose(fileID_Ha);

%% Initial values

N=2048;
fs=8000;
Nfft=512;
M=32;
L=32;
fs_lo = fs/M;
f_i = 0:1/Nfft:(Nfft/2-1)/Nfft; % Normalized frequencies


%% Input Signal

noise = randn([1 N]);
x1 = sin(pi*4000/fs*(1:N));
x2 = sin(pi*25/fs*(1:N));

x = noise + x1 + x2;
X = fft(x,Nfft);

%% DSP Chain

x0 = conv(x,Ha);
y1 = x0(1:M:length(x0));
Y1 = fft(y1,Nfft);

y2 = conv(y1,Hk);
Y2 = fft(y2,Nfft);

y3(1:M:M*length(y2)) = y2;
Y3 = fft(y3,Nfft);

y = conv(y3,Ha);
Y = fft(y,Nfft);

Hk_pxx = pwelch(Hk);
Ha_pxx = pwelch(Ha);


%% Plot 

figure
subplot(521); plot(x); title("x");
subplot(522); plot(f_i,abs(X(1:Nfft/2))); 
        title("|X_u(e^j^\omega)|");
subplot(523); plot(y1); title("y1");
subplot(524); plot(f_i,abs(Y1(1:Nfft/2))); 
        title("|Y1_u(e^j^\omega)|");
subplot(525); plot(y2); title("y2");
subplot(526); plot(f_i,abs(Y2(1:Nfft/2))); 
        title("|Y2_u(e^j^\omega)|");
subplot(527); plot(y3); title("y3");
subplot(528); plot(f_i,abs(Y3(1:Nfft/2))); 
        title("|Y3_u(e^j^\omega)|");
subplot(529); plot(y); title("y");
subplot(5,2,10); plot(f_i,abs(Y(1:Nfft/2))); 
        title("|Y_u(e^j^\omega)|");
        
figure 
subplot(211)
plot(10*log10(Hk_pxx))
ylabel('Hk[n]')
xlabel('w')
title('Hk PSD Estimation')

subplot(212)
plot(10*log10(Ha_pxx))
title('Ha PSD Estimation')
ylabel('Ha[n]')
xlabel('w')
title('Ha PSD Estimation')




% Test the output versus the input signal
% subplot(4,3,12); plot(y-x);
%         title("y-x");
